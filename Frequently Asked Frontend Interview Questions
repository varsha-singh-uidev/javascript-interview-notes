## Most Frequently Asked Frontend Interview Question ##

## HTML ##
1. What are semantic HTML elements? Give examples.
Ans = Semantic elements clearly describe their meaning and purpose to both the browser and developers(<header>, <footer> etc).
      They improve: Accessibility, SEO, Code readability.

2. Difference between block, inline, and inline-block elements?
Ans = Block: Takes full width, starts on a new line. Example: <div>, <p>.
      Inline: Take as much as width needed for their content, doesn’t start from a new line. Example: <span>, <a>.
      Inline-block: Behaves like inline but allows setting width/height. Example: <img>.

3. What is the difference between <div> and <span>?
Ans = <div>: Block-level, starts from the new line, used to group larger sections of content.
      <span>: Inline-level, doesn't start from the new line, used to style or mark small parts of text.

4. What are HTML5 new features?
Ans = Key additions:
      Semantic elements: <header>, <footer>, <article>
      Multimedia: <audio>, <video>
      Graphics: <canvas>, <svg>
      APIs: Geolocation, Drag & Drop, Web Storage
      Form enhancements: email, date, required, placeholder.

5. Difference between HTML and XHTML?
Ans = HTML (HyperText Markup Language)
      Introduced: 1991 by Tim Berners‑Lee.
      Flexible rules: Browsers forgive small mistakes (like unclosed tags).
      Case-insensitive: Tags can be uppercase or lowercase.
      Attributes: Quotes around attribute values are optional.
      Goal: Easy to write, more forgiving for developers.

<!-- Valid in HTML -->
<p>Hello World
<br>

    XHTML (Extensible HyperText Markup Language)
    Introduced: January 26, 2000 (XHTML 1.0 by W3C).
    Strict rules: Must follow XML syntax.
    Case-sensitive: Tags must be lowercase.
    Well-formed: Every tag must be properly closed (<br /> instead of <br>).
    Attributes: Values must always be quoted.
    Goal: Cleaner, consistent code and well‑formed documents.

<!-- Required in XHTML -->
<p>Hello World</p>
<br />

6. Difference between id and class?
Ans = (id)
      Unique identifier for a single element.
      Can’t be reused on multiple elements in the same page.
      Used when you want to target one specific element.
      Higher CSS priority.
      Example: <h1 id="main-title">Welcome</h1>

      (class)
      Can be applied to multiple elements.
      Useful for grouping and styling many elements together.
      Often used with CSS and JavaScript for shared behavior.
      Lower CSS priority.
      Example: <p class="highlight">First paragraph</p>

7. Difference between relative, absolute, and fixed URLs?
Ans = Relative URL
      Definition: Points to a file relative to the current page’s location.
      Use: Shorter, depends on where the file is stored.
      Example: If your page is in a folder, and the image is in the same folder, you just say: <img src="logo.png">

      Absolute URL
      Definition: Full path including domain name.
      Use: Always points to the same resource, no matter where the page is.
      Example: This is the full address of something on the internet. <img src="https://example.com/images/logo.png">

      Fixed URL
      Definition: A fixed URL is a link that always points to the same place on a website, no matter where the page is.
      Use: Tied to a specific location, less flexible.
      Example: Starts from the root (home) of the website. <img src="/images/logo.png">

8. What are data-* attributes used for?
Ans = Definition: data-* attributes are custom attributes in HTML used to store extra information about an element without
      affecting the layout and behavior.
      Purpose: They let developers add small bits of data to HTML elements, which can later be accessed with JavaScript.

      Example: <button data-user-id="123">Click</button>
               const btn = document.querySelector("button");
               console.log(btn.dataset.userId);

9. Difference between <script>, <script async>, and <script defer>?
Ans = <script>
      Default behavior: Browser stops loading the page, runs the script immediately, then continues.
      Effect: Can block page rendering if the script is large.

      <script async>
      Behavior: Script loads in the background while the page continue loading.
      Effect: Once Script loads it runs it immediately(may interrupt page rendering).

      <script defer>
      Behavior: Scripts load in the background but waits untill the Html is fully parsed.
      Effect: Script runs after the page is ready.

10. Difference between <link> and @import for CSS?
Ans = (Link)
      where is used: It is used inside the Html.
      Deffination: It is an Html tag that is used to include the external CSS file.
      Behaviour: It loads CSS file while the page loads(faster).
      Support: It is widely supported.
      Best for: Modern Website.

      (@import)
      where is used: It is used inside the CSS file.
      Deffination: A CSS rule used inside the stylesheet to import another CSS file.
      Behavior: CSS loads after the page loads(slower).
      Support: It is less Supported.
      Best for: Rarely used today.

11. What are meta tags in HTML?
Ans = Meta tag in the html gave the metadata about the page. They describe the character encoding, 
      viewport setting, page description and author of the page. Always placed in the <head> element.
      Not visible to user, but important for the SEO, accessiblity, and browser behaviour.

12. Difference between <canvas> and <svg>?
Ans = (Canvas):
      i) Canvas is pixels based. zooming can make it blurry.
      ii) Shapes are not stored as an element.
      iii) Better for the things that change a lot like gaming or animation.
      iv) Not scalable

      (svg):
      i) Svg is vector-based. zooming keeps it sharp.
      ii) Each Shape is an  element in the DOM.
      iii)Better for the static graphics like icons, diagram etc.
      iv) Scalable - Show good at any size.

13. Difference between localStorage, sessionStorage, and cookies?
Ans = localStorage
      Definition: Stores data in the browser permanently (until manually cleared).
      Lifetime: Data stays even after closing the browser or restarting the computer.
      Size limit: Around 5–10 MB (much larger than cookies).
      Use case: Saving user preferences, themes, or app state.

      sessionStorage
      Definition: Stores data only for the current browser tab/session.
      Lifetime: Data is lost when the tab or browser is closed.
      Size limit: Similar to localStorage (~5 MB).
      Use case: Temporary data like form inputs or session‑specific state.

      Cookies
      Definition: Small pieces of data stored in the browser and sent to the server with every request.
      Lifetime: Can be temporary (session cookies) or persistent (with an expiry date).
      Size limit: Much smaller (~4 KB).
      Use case: Authentication, tracking, server communication.

14. What are accessibility (ARIA) attributes? Why important?
Ans = ARIA(Accessible Rich Internet Application) attribute are the extra html attribute that make the   
      website usable for the peaple with disablity. They provide the information to the technologies 
      like (screen readers) about the roles, states and relationships of elements.
      Example = <button aria-label="Button">Click</button>

15. Difference between <section>, <article>, <aside>, and <main>?
Ans = <main>: The main content of the page, Only one <main> per page. 
      <section>: A part of the page that groups the related content.
      <article>: A block of content that can stand alone.
      <aside>: Extra content on the side.

## CSS ##

1. Difference between relative, absolute, fixed, and sticky positioning with example?
Ans = Relative: The element stays in the normal document flow, but you can shift it using(top, left, right or bottom).
      Absolute: It removes from the normal flow, and positioned relative to nearest position ancestor.
      Fixed: Position relative to the viewport, Stays fixed on the screen even when scrolling.
      Sticky: Acts relative untill a scroll threshold, then behave like fixed.

2. What is the difference between inline, internal, and external CSS?
Ans = Inline CSS: Written directly inside the html element using the style attribute, affects only that single element,
      It is hard to maintain in large projects Example = <p style="color:red;">Hello</p>

      Internal CSS: Written inside the <style> tag in the <head> of the html file, Affects only that single html page.
      It is not reusable accross multiple pages.
      Example = <style> p{color : red;}  </style>

      External CSS: Written inside the seperate .css file and linked with the html using the <link> tag, Can style multiple
      pages at once, Best for performance and maintainablity. 
      Example = <link rel="stylesheet" href="style.css">

3. Difference between relative units and absolute units (%, em, rem, vw, vh, px)?
Ans = Relative Units: It is responsive units means, they scale with the context(like parent size, root fontsize or viewport).
      Example of units are:
   a) %(percentage): Relative to parent element.
      Example = div { width: 50%; } /* Half of parent’s width */
   b) em: Relative to the parent font size.
      Example = p { font-size: 2em; } /* Twice parent’s font size */
   c) rem: Relative to the root(html) font size.
      Example = p { font-size: 1.5rem; } /* 1.5 × root font size */
   d) vw: Relative to the width of the browser window.
      Example = div { width: 50vw; } /* 50% of viewport width */
   e) vh: Relative to the height of the browser window.
      Example = div { width: 100vh; } /* Full viewport height */

      Absolut Units: Fixed units, that do not change with the context.
      Example of units are:
   a) px(pixels): Smallest unit of measurement on a digital screen they do not scale with the context.
      Example = p { font-size: 16px; } /* Always 16 pixels */

4. What is the difference between Flexbox and CSS Grid? When to use which?
Ans = Flexbox: A one dimensional layout system(works in a row OR column). It was best for aligning the item along a single axis.
      It was used in the Navigation bars, Centering the elements, distributing the even space between the items.

      Grid: A two dimensional layout system(works in rows AND columns). It was best for the complex page layout.
      It was used in the Dashboard, Full web page structure.

5. Difference between inline vs block elements in terms of CSS?
Ans = Inline Elements: Does not start from the new line. Take as much width that are needed for there content. we can not set
      width/height directly. we can set the padding/margin in inline element but only in the left and right side not in the top/bottom.
      Multiple iinline element can sit together side by side. Example are <span>, <a>, <strong>.

      Block Element: Starts fromt the new line. Takes the full width available. we can set the width, height, padding and margin.
      Each bloack element stacks vertically. Example are <div>, <p>, <section>.

6. What is z-index and how does it work?
Ans = z-index: It controls the stacking order of element on a webpage. It only works with the element that have a 
      position(relative, absolute, fixed or sticky). The element that has the higher z-index appears on the top of the element has lower z-index.

7. Explain the concept of CSS Specificity.
Ans = CSS specificity is the set of rules that determines which CSS rule takes priority when multiple style target the same element.
      Specificity is calculated basced on the type of selector:
      Inline > ID > Class, pseudo-classes > Elements and pseduo-elements.

8. Difference between visibility: hidden and display: none?
Ans = (visibility: hidden): Hides the element but still keeps its space in the layout.
      (display: none): Completely removes the element from the layout, and also its space is gone other element is shift to fill the gap.

9. What is the difference between transform, transition, and animation in CSS?
Ans = Transform: It is used to change the shape, size, or position of an element. It show the changes instantly no smooth effect by itself.
      Transition: Create the smooth effect when a property changes from one value to another. It show the changes when the element triggered 
      (like hover, focus or state change).
      Animation: Allows continuous, complex or repeat the effect using the keyframes. Effects can run automatically or in loop.

10. What are pseudo-classes and pseudo-elements? Examples?
Ans = Pseudo-classes: define the state of an element(like hover, focus etc). They let you style the element basced on the user interaction or 
      document structure without adding the extra classes.
      Example: a:hover{color: red} //change the link when hover.

      Pseudo-elements: allow you to style the specific part of an element(like the first letter, first line, or content before/after).
      they use the (::) double colon in modern css.
      Example: p::first-line{ color: green; }//style the first line of a paragraph.

11. What are media queries and how do they work?
Ans = Media queries are a css feature that allow the developer to apply the style based on the specific conditions
      (like viewport width, height, orientation or device type). They are the backbone of responsive design, ensuring the website adapt to 
      desktop, tablets and mobile devices seamlessly.
      Syntax Exmaple: @media(condition) { /* CSS rules here */ }

12. Difference between min-width and max-width in responsive design?
Ans = min-width: Styles apply when the screen width is greater than or equal to the specified value. Often used in (Mobile-first design).
      max-width: Styles apply when the screen width is less than or equal to the specified value. Often used in (Desktop-first design).

13. Difference between CSS BEM methodology and normal CSS? 
Ans = Normal CSS
      Definition: Traditional CSS where you write selectors freely (.header, .nav ul li a, etc.).
      Issues:
      Naming collisions (same class names reused across files).
      Harder to maintain in large projects.
      Deeply nested selectors → less readable and harder to override.

      BEM (Block, Element, Modifier)
      Definition: A naming convention for CSS classes that makes styles more structured and predictable.
      Structure:
      Block: Independent component (.button)
      Element: Part of the block (.button__icon)
      Modifier: Variation of block/element (.button--primary)
      Benefits:
      No naming collisions.
      Easier to scale and maintain.
      Clear relationship between components.

## JavaScript ##

1. Difference between var, let, and const?
Ans = var: Function‑scoped (available throughout the function where declared).
      Hoisting: Hoisted to the top of its scope and initialized as undefined.
      Re‑declaration: Allowed (you can declare the same variable multiple times).
      Re‑assignment: Allowed.

      let: Block‑scoped (only available inside {} where declared).
      Hoisting: Hoisted but not initialized → Temporal Dead Zone until declared.
      Re‑declaration: Not allowed in the same scope.
      Re‑assignment: Allowed.

      const: Block‑scoped (like let).
      Hoisting: Same as let (Temporal Dead Zone).
      Re‑declaration: Not allowed.
      Re‑assignment: Not allowed (value is constant).

2. What is the difference between == and ===?
Ans:  == (Loosly Equality Operator)
      Definition: Compares two values for equality after type conversion (type coercion).
      Behavior: If the types are different, JavaScript tries to convert them to the same type before comparing.

      === (Strict Equality Operator)
      Definition: Compares two values for equality without type conversion.
      Behavior: Both value and type must match exactly.

3. What is hoisting in JavaScript?
Ans = Hoisting is JavaScript default behavior of moving declarations(not initializations) to the top of their scope(function or global).
      Only the decleration is hoisted, not the assignment.

   1. Variable Hoisting: 
      var: Declaration is hoisted imediately asssigned with the value of undefined.
      let and const: Declaration is hoisted but not initialized. They remain in the special zone called Temporal Dead Zone until the actual delcelaration line.

   2. Function Hoisting:
      Function Declaration: Fully hoisted we can call them before they are defined.
      Function Expression / Arrow Function: Not hoisted.

3. Difference between null and undefined?
Ans = undefined
      Definition: A variable that has been declared but not assigned a value is undefined.
      Default behavior: JavaScript automatically assigns undefined to uninitialized variables.
      Example: let a;
               console.log(a); //undefined

      null
      Definition: An intentional assignment of “no value.”
      Behavior: You explicitly set a variable to null to indicate it should be empty. 
      Example: let a = null;
               console.log(a); //null

4. What is closure in JavaScript?
Ans = Deffination: A closure is formed when an inner function captures variables from its outer (lexical) scope.
      Even after the outer function returns, the inner function retains access to those variables.
      This happens because JavaScript uses lexical scoping and keeps references to the environment where the function was created
      Example: function outer(x){
                 let y = 10;
                 function inner(){
                    return x + y;
                  } 
                  return inner;
                 }
      const closure = outer(5);
      console.log(closure());

5. Difference between synchronous and asynchronous JavaScript?
Ans = Synchronous JavaScript
      Definition: Code is executed line by line, in order.
      Behavior: Each statement must finish before the next one starts.
      Blocking: If one task takes time (like a heavy calculation), it blocks everything else.

      Asynchronous JavaScript
      Definition: Code execution can continue without waiting for a task to finish.
      Behavior: Long‑running tasks (like API calls, timers, file reads) run in the background, and results are handled later.
      Non‑Blocking: Other code executes while waiting.

6. Difference between event bubbling and event capturing?
Ans = Event Bubbling:
      Definition: When an event occurs on an element, it first runs the handler on that target element, then on its parent, and continues up the DOM tree.
      Default behavior: Most events in JavaScript use bubbling by default.
      Example:
      <div onclick="alert('DIV clicked')">
        <button onclick="alert('Button clicked')">Click Me</button>
      </div>

      Event Capturing:
      Definition: The opposite of bubbling. The event is first captured by the outermost ancestor and then propagated down to the target element.
      Activation: You must explicitly enable capturing by passing true as the third argument in addEventListener.
      Example:
      div.addEventListener("click", () => alert("DIV clicked"), true);
      button.addEventListener("click", () => alert("Button clicked"), true);     

7. What is the difference between call, apply, and bind methods?
Ans = call(): Invoked the function immediately, with a specified (this) value and arguments provide individually.
      Example: const user = {
                 name : "bob",
                 greet(){ console.log(`Hello ${this.name}`); }
               }
      const sayhello = user.greet;
      sayhello.call(user);

      apply(): Similar to the (call()). Function invoked immediately but the argument are passed as an array.
      Exmaple: function greet(city1, city2){
                      console.log(`Hello, ${this.name} are you from ${city1} or ${city2}?`);
                }
               const user = {name : "bob"}
               greet.apply(user, ["america", "new york"]);

      bind(): It is used when you want to fix the (this) context and want to reuse the function later this thing was commonly used in (event handlers).
      Exmaple: function greet(city1){
                  console.log(`Hello, ${this.name} are you from ${city1}?`);
                }
      const user = {name : "bob"};
      const bound = greet.bind(user, "america");
      bound();

8. Difference between shallow copy and deep copy in JS?
Ans = Shallow Copy
      Definition: A shallow copy duplicates only the top‑level properties of an object.
      Nested objects/arrays: They are not cloned — instead, the copy still points to the same reference in memory.
      Effect: If you change something inside a nested object/array in the copy, the original will also change (because they share the same reference).

      Example: // shallow copy
      const obj = {
          name : "bob",
          add : {
              city : "UP"
          }
      }
      const obj1 = Object.assign({}, obj);
      obj1.add.city = "Uttar Pradesh";
      console.log(obj); 
      console.log(obj1);
      //Changes are refleced on both of the object 

      Deep Copy
      Definition: A deep copy duplicates all levels of properties, including nested objects and arrays.
      Nested objects/arrays: They are cloned into new memory locations, not shared with the original.      
      Effect: Changes in the copy do not affect the original, because they no longer share references.

      Example: 
      const obj1 = {
            name : "bob",
            add : { city : "UP" }
      }
      function deepCopy(obj){
    
          if(typeof(obj) !== "object" || obj === null){
              return obj;
          }
    
          let result = Array.isArray(obj)? [] : {};
          let key = Object.keys(obj);
    
          for(let i = 0; i < key.length; i++){ result[key[i]] = deepCopy(obj[key[i]]); }
    
          return result;
      }
      const obj2 = deepCopy(obj1);
      console.log(obj2);

9. What are promises in JavaScript?
Ans = A Promise in JavaScript is an Object that represent the eventual completion and failure of an asynchronous operation
      
      States of a Promise:
      Pending: Initial state, operation not yet completed.
      Fulfilled: Operation completed successfully, returns a value.
      Rejected: Operation failed, returns an error reason.

      Promise Methods:
      .then() → handle success.
      .catch() → handle errors.
      .finally() → run code regardless of success or failure.
      Promise.all() → run multiple promises in parallel, wait for all to finish.
      Promise.race() → returns the result of the first promise that settles.

10. Difference between promise chaining and async/await?
Ans = Promise Chaining: It uses the .then() and .catch() to handle multiple asynchronous operation sequentially. Can became hard to read and manage when 
      many .then() blocks are chained. A single .catch() at the end to handle the error.

      async/await = It is syntactic sugar built on the top of promise that make the asynchronous code look synchronous. Uses the try...catch for error
      handling. Easier to read, write and debug compared to long chain of .then(). 

11.What is the difference between localStorage and sessionStorage?
Ans = LocalStorage vs SessionStorage in JavaScript
      1. Definition
      localStorage: Stores data in the browser with no expiration date. Data persists across tabs, and browser restarts until explicitly cleared.
      sessionStorage: Stores data for the current browser tab session only. Data is lost once the tab or browser is closed.

      2. Scope
      localStorage: Shared across all tabs and windows of the same origin (domain + protocol + port).
      sessionStorage: Unique to each tab/window. Opening the same site in a new tab creates a fresh sessionStorage.

      3. Capacity
      localStorage: Its capacity is ~10MB.
      sessionStorage: Its capacity is around ~5MB.

      4. Use Cases
      localStorage: Saving user preferences (theme, language), Caching data for offline use and
      Persisting login tokens (though not recommended for sensitive data).
      sessionStorage: Temporary form data, Shopping cart data for a single session and State that should reset when the tab closes.

12. Difference between setTimeout and setInterval?
Ans = setTimeout = Runs once after a specified delay, We can clear the timeout using the clearTimeout(id) method.
      setInterval = Runs a function repeatedly at a specified interval, we can clear the interval using the clearInteval(id) method.

13. What is the difference between arrow functions and normal functions?
Ans = Arrow Function: It was introduced in ES6. It was the shorter syntax to write the function. 
      Arrow function do not have their own this. They inherit the this from the lexical scope.
      Cannot be used as a constructor(new keyword won't work).
      Do not have their own arguments object.

      Normal Function: Have their own this(depend how the function is called).
      Can be used as a constructor with new.
      Have their own argument object.

14.Difference between for...in and for...of loops?
Ans = for...in: Iterates over the keys (property names) of an object.
      Works on: Objects (and arrays, but not recommended).

      Example: 
      const obj = {name : "bob", age : 30};
      for(let key in obj){console.log(key, obj[key]);}

      for...of: Iterates over the values of an iterable (arrays, strings, Maps, Sets, etc.).
      Works on: Iterables (not plain objects unless you use Object.values() or Object.entries()).

      Example:
      const arr = ["a", "b", "c"];
      for(let value of arr){console.log(value);}

15. What is the difference between DOM and BOM?
Ans = DOM (Document Object Model): A programming interface for HTML documents.
      Purpose: Represents the structure and content of a webpage as a tree of nodes.
      Focus: Deals with document elements (tags, attributes, text).

      BOM (Browser Object Model): A programming interface for the browser itself.
      Purpose: Represents the browser environment outside the page content.
      Focus: Deals with browser features (window, history, location, navigator, screen).

16. Difference between innerHTML and innerText?
Ans = innerHTML: Retrun or set the HTML content inside an element — including the tags and the text between them.
      innerText: Return or set the visible text inside an element, ignoring the html tag.

17. What is the difference between event delegation and event handling?
Ans = Event Handling: Attaching an event listener directly to the element you want to respond to.
      How it works: The listener is bound to that specific element.
      Use case: When you only need to handle events on a few known elements.

      Event Delegation: Attaching a single event listener to a parent element and using "event bubbling" to detect which child triggered the event.
      How it works: Instead of adding listeners to every <li>, you add one listener to the <ul> and use "event.target" to figure out which child triggered it.
      Use case: Efficient when handling events on many dynamic child elements (like items in a list).

18. Difference between ES5 and ES6 features?
Ans = ES5:
      var only
      Normal function
      Modules are not supported
      Async handling are done by the "Callbacks"
      String are written with "Concatenation +"

      ES6:
      Introduce let and const
      Arrow Function
      Modules are introduced
      Async handling are done by the "Promises"
      Introduce template literal

19. What are higher-order functions in JavaScript?
Ans = A function is considered higher‑order if it does one (or both) of the following:
       i  Takes another function as input (argument).
       ii Returns a new function as output.
      This is possible because in JavaScript, functions are first‑class citizens — meaning they can be stored in variables, passed around, 
      and returned just like numbers or strings.

20. What is the difference between JSON and JavaScript objects?
Ans = JSON(JavaScript Object Notation): A text-based data format Mostly used when sending/receiving the data between server and browser.
      Keys and value must be in double quotes.
      Cannot store function and methods.      
      Example {"name" : "bob", "role" : "developer"}

      JavaScript Objects: It is a data Structure in JavaScript. Used to store the key-value pair.
      Keys can be of any data type and write without the quotes.
      Values can be strings, numbers, arrays, other objects, or even functions.
      Exmaple: 
      const person = {
        name: "Varsha",
        age: 25,
        skills: ["JavaScript", "React"],
        greet: function() { console.log("Hello!"); }
      };

21. Difference between mutable and immutable data in JS?
Ans = Mutable Data: Data that can be changed/modified after it is created.
      Examples in JS: Objects, Arrays
      Behavior: If you change a property or element, the original data structure is updated.

      Immutable Data: Data that cannot be changed once created. Any modification creates a new copy.
      Examples: Primitive types → string, number, boolean, null, undefined, symbol, bigint
      Behavior: If you try to change them, a new value is created instead of modifying the original.

22. Difference between map(), forEach(), filter(), and reduce()?
Ans = forEach(): Loops through each element of array and execute the callback.
      Return: Nothing(undefined)
      Example: const arr = [1, 2, 3];
      arr.forEach(num => console.log(num * 2)); // Output: 2, 4, 6

      map(): Creates a new array by transforming each element.
      Return: A new array of same length.
      Example: const arr = [1, 2, 3];
      const doubled = arr.map(num => num * 2);
      console.log(doubled); // [2, 4, 6]

      filter(): Creates a new array with only elements that pass a condition.
      Return: A new array.
      Example: const arr = [1, 2, 3, 4];
      const evens = arr.filter(num => num % 2 === 0);
      console.log(evens); // [2, 4]

      Reduce(): Reduce an array to a single value by applying the function.
      Return: A single value.
      Example: const arr = [1, 2, 3, 4];
      const sum = arr.reduce((acc, num) => acc + num, 0);
      console.log(sum); // 10

23. What is the difference between functional programming and OOP in JS?
Ans = Object‑Oriented Programming (OOP)
      Organizes code around objects and classes (data + behavior together).
      Uses classes and instances.
      Focuses on encapsulation, inheritance, and polymorphism.
      Data is often mutable (object properties can be changed).
      Reusability comes from class hierarchies and inheritance.
      Best for modeling real‑world entities (e.g., User, Car, Order).

      Functional Programming (FP)
      Organizes code around functions and data transformations.
      Uses pure functions (no side effects, same input → same output).
      Focuses on immutability and function composition.
      Data is usually immutable (new copies created instead of modifying).
      Reusability comes from higher‑order functions and composition.
      Best for data processing pipelines (map, filter, reduce).

24. Difference between prototype and __proto__?
Ans = prototype:
      exists on constructor function.
      Used to defines what property/method that should be inherited by all instances created with new.
      used when creating reusable methods for all instances.
      an object property of functions.

      __proto__:
      exists on all objects.
      It is a hidden property that points to the object's prototype.
      used internally to connect objects in the prototype chain.
      a reference (pointer) to another object.
      used internally to connect objects in the prototype chain.

25. What is the difference between class and constructor function in JS?
Ans = class: 
      Classes are syntactic sugar over constructor functions.
      More readable and structured.
      Not hoisted.
      Both require new to create instances. but class throw error if new is missing.
      Methods automatically go to prototype.
      Introduce inheritance using the extends and super.
      Always runs in strict mode. Safer by default.

      constructor:
      Function-based, used to create objects.
      Harder to read in large codebases.
      Hoisted.
      Both require new to create instances.
      Methods added via prototype manually.
      Introducing inheritance is error-prone.
      Not strict by default.

26. Difference between import and require?
Ans = require: 
      It is a older way of importing the modules in JavaScript.
      It loads the modules synchronously(one after another, bloacking).
      Uses (module.exports).
      can be called anywhere in the code.
      Not hoisted, runs when called.

      import:
      It is a modern way.
      It loads the modules asynchronously(non-bloacking).
      Uses (export and export default).
      must be at the top, but support dynamic import() too.
      hoisted to the top automatically.

27. Difference between debouncing and throttling in JavaScript?
Ans = Debouncing:
      Run after user stop triggering the event.
      Debouncing is useful when you only want the action to happen once after a pause, like waiting until typing stops in a search box.
      Debouncing resets the timer every time the event is fired, so the function only runs after event stop fire.
      Best for input fields, resize events.

      Throttling:
      Runs at fixed intervals while event keep firing.
      Throttling is useful when you want the action to happen regularly, like updating scroll position while the user scrolls.
      Throttling ignores extra events during the delay period and only allows the function to run once per set interval.
      Best for Scroll, mouse move, or repeated clicks.

28. What is the difference between REST API and GraphQL in frontend usage?
Ans = REST API:
      It stands for Representation State Transfer. It is a way for frontend and backend to talk to each other using HTTP requests.
      REST API uses many endpoints for different resources.
      REST API decides what data to send back.
      REST API may require multiple requests to get related data.
      REST API uses HTTP methods like GET, POST, PUT, DELETE.
      REST API is easier to cache because endpoints are fixed.
      REST API can return extra or missing data.
      REST API is older and widely supported.

      GraphQL:
      It is a query language for API's created by facebook. It gives the frontend more control over what data it wants.
      GraphQL uses a single endpoint for all requests.
      GraphQL lets the client choose exactly what data it wants.
      GraphQL can fetch everything in one request.
      GraphQL uses queries and mutations.      
      GraphQL caching is more complex.
      GraphQL returning only the requested fields.
      GraphQL is newer and popular in modern frontend frameworks like React.

## React ##

1. What is the difference between functional and class components?
Ans = Functional Component:
      A plain JavaScript function that returns JSX.
      Use hooks like useState, useEffect for managing the state and side effect.
      Lightweight, faster and easier to test.
      Hooks allow easy reuse of logic across different components.
      easier to test since they are pure functions.
      widely used and recommended in modern React apps.

      Class Component:
      class that extends React.Component and has a render() method.
      Manage the state use this.state and update the state with the this.setState().
      Slightly heavier due to this binding and class overhead.
      reuse is harder, often requires higher-order components or render props.
      more complex due to (this) context.
      legacy approach, still supported but less common in new projects.

2. What are React hooks? Common hooks?
Ans = React Hooks are special functions in React that let you use state and other React features inside functional components 
      without writing class components.
      Commonly Used React Hooks are:
      1. useState: use to manage the state.
      2. useEffect: handles side effects.
      3. useMemo: Memoizes expensive calculations.
      4. useCallback: Memoizes functions to prevent unnecessary re-renders.
      5. useLayoutEffect: Similar to useEffect but runs synchronously after DOM mutations.


3. Difference between useEffect and useLayoutEffect?
Ans = Difference Between useEffect and useLayoutEffect are:

      Execution Timing
      useEffect: Runs after the browser has painted the UI.
      useLayoutEffect: Runs before the browser paints the UI.

      Blocking vs Non‑Blocking
      useEffect: Non‑blocking → the user sees the updated screen immediately, then the effect runs.
      useLayoutEffect: Blocking → delays the paint until the effect finishes.

      Use Cases
      useEffect: Best for side effects like API calls, logging, subscriptions, timers.
      useLayoutEffect: Best for DOM measurements, synchronizing layout, or animations that depend on exact element sizes/positions.

      Performance
      useEffect: More efficient, doesn’t slow down rendering.
      useLayoutEffect: Can hurt performance if heavy work is done, because it blocks paint.

4. What is the difference between controlled and uncontrolled components?
Ans = Difference Between Controlled and Uncontrolled Components in React are:

      Definition
      Controlled Component: The form data is handled by React state.
      Uncontrolled Component: The form data is handled by the DOM itself.

      Data Source
      Controlled: Value of input comes from React state (value={state}).
      Uncontrolled: Value of input comes directly from the DOM (defaultValue or ref).

      State Management
      Controlled: You must use useState (or this.state in class components) to manage input values.
      Uncontrolled: You access values using refs (e.g., inputRef.current.value).

      Updates
      Controlled: Every keystroke updates React state, and React re-renders the component.
      Uncontrolled: The DOM updates the value internally; React doesn’t track every change.

      Code Complexity
      Controlled: More code, but predictable and easier to debug.
      Uncontrolled: Less code, but less predictable and harder to maintain.

      Use Cases
      Controlled: Preferred for most forms where validation, dynamic updates, or controlled behavior is needed.
      Uncontrolled: Useful for quick forms, simple inputs, or when you don’t need React to manage the state.

5. Difference between state and props in React?
Ans = Difference Between State and Props in React are:

      Definition
      State: A built‑in object that stores data inside a component.
      Props: Short for “properties,” they are inputs passed from parent to child components.

      Mutability
      State: Mutable — can be changed using setState (class) or useState (functional).
      Props: Immutable — cannot be modified by the child component; read‑only.

      Ownership
      State: Owned and managed by the component itself.
      Props: Owned by the parent and passed down to child components.
      
      Usage
      State: Used for data that changes over time (user input, toggles, counters).
      Props: Used to pass data and functions between components.

      Updates
      State: Updates trigger re‑render of the component.
      Props: Changes in props (from parent) also trigger re‑render of the child.

6. What is the difference between useMemo and useCallback?
Ans = Difference Between useMemo and useCallback:

      Purpose
      useMemo: Memoizes a value (result of a computation).
      useCallback: Memoizes a function (so its identity doesn’t change).
      
      Return Type
      useMemo: Returns the computed value.
      useCallback: Returns the function itself.

      Use Cases
      useMemo: Optimize expensive calculations (e.g., filtering, sorting, math).
      useCallback: Prevent unnecessary re‑creation of functions passed as props to child components.

      Dependencies
      Both accept a dependency array.
      useMemo: Recomputes the value only when dependencies change.
      useCallback: Recreates the function only when dependencies change.

      Performance Benefit
      useMemo: Saves CPU cycles by caching results.
      useCallback: Saves memory/re‑renders by keeping function identity stable.

7. What are React keys and why are they important?
Ans = In react key are used when rendering lists. Keys give each element a stable identity So, React can match 
      old and new elements during the reconciliation process. Without keys, React may reuse DOM nodes incorrectly.
      Keys help React know which items stayed the same, which changed, and which were removed.
      Important: Avoid using array indices as keys unless the list is static and never reordered.
      Keys must be stable — they should not change between renders.

8. Difference between React.Fragment and a div wrapper?
Ans = Difference Between React.Fragment and a div Wrapper

      Extra DOM Node
      React.Fragment: Does not add an extra DOM node.
      div: Adds an extra <div> element to the DOM.

      Clean DOM Structure
      React.Fragment: Keeps the DOM clean and minimal.
      div: Can lead to unnecessary nesting and “div soup.”

      Styling & Layout
      React.Fragment: Cannot have CSS classes, IDs, or styles because it doesn’t render a real element.
      div: Can be styled directly with classes, IDs, or inline styles.

      Use Case
      React.Fragment: Best when you just need to group multiple children without affecting layout or styling.
      div: Best when you need a real container element for styling, layout, or semantic structure.

9. What is the difference between React virtual DOM and real DOM?
Ans = Difference Between Virtual DOM and Real DOM are:

      Definition
      Real DOM: The actual Document Object Model rendered and managed by the browser.
      Virtual DOM: A lightweight, in‑memory representation of the real DOM maintained by React.

      Update Speed
      Real DOM: Updates are slow because every change triggers reflow/repaint of the entire UI.
      Virtual DOM: Updates are fast because React calculates diffs and only applies minimal changes.

      Performance
      Real DOM: Inefficient for frequent updates; large UIs can lag.
      Virtual DOM: Optimized for dynamic UIs; reduces direct manipulation of the real DOM.

      Re-rendering
      Real DOM: Entire UI may re-render when a change occurs.
      Virtual DOM: Only the changed nodes are updated after React’s diffing algorithm.

      Developer Interaction
      Real DOM: Developers manipulate it directly with vanilla JS (document.getElementById, etc.).
      Virtual DOM: Developers work with React components; React handles DOM updates internally.

      Memory Usage
      Real DOM: No extra memory overhead beyond the actual DOM tree.
      Virtual DOM: Requires additional memory to maintain the virtual copy.

10. Difference between Context API and Redux?
Ans = Difference between Context API and Redux are:

      Type
      Context API → Built‑in React feature.
      Redux → External library for state management.

      Setup Complexity
      Context API → Minimal setup (createContext, Provider, useContext).
      Redux → More boilerplate (Store, Actions, Reducers, Middleware).

      Best Use Cases
      Context API → Avoiding prop drilling, sharing simple global state (theme, auth, language).
      Redux → Large apps with complex state changes, multiple interactions, and async logic.

      State Management
      Context API → Provides global context but no strict structure.
      Redux → Centralized store with predictable state transitions via reducers.

      Performance
      Context API → Can cause unnecessary re‑renders if many components consume the same context.
      Redux → Optimized with reducers and middleware; better for large‑scale performance.

      Debugging Tools
      Context API → Limited (React DevTools only).
      Redux → Powerful Redux DevTools (time‑travel debugging, state inspection).

      Middleware Support
      Context API → Not available.
      Redux → Supports middleware (Redux Thunk, Saga) for async operations.

      Learning Curve
      Context API → Easy to learn, minimal boilerplate.
      Redux → Steeper learning curve, requires understanding of actions/reducers.

      Community & Ecosystem
      Context API → Smaller, React‑only.
      Redux → Large ecosystem with plugins, middleware, and integrations.

11. Difference between lazy loading and code splitting?
Ans =  Difference between lazy loading and code splitting are:

      Purpose
      Lazy Loading → Delays loading until needed.(load pieces only when needed.)
      Code Splitting → Divides code into smaller bundles.(cutting your app into smaller pieces.)

      Focus
      Lazy Loading → Focuses on when resources are loaded.
      Code Splitting → Focuses on how resources are organized and delivered.

      Implementation
      Lazy Loading → Often implemented with dynamic imports (import()), React’s React.lazy, or image/data loading strategies.
      Code Splitting → Achieved using bundlers like Webpack, Rollup, or Parcel.

      Performance Benefit
      Lazy Loading → Reduces initial load time by skipping unused parts.
      Code Splitting → Prevents one giant bundle, making downloads smaller and faster.

      Relationship
      Lazy Loading → Usually relies on code splitting under the hood (because you need separate chunks to load later).
      Code Splitting → Can exist without lazy loading (just splitting bundles but still loading them all upfront).

      Use Case
      Lazy Loading → Best for rarely used features (admin panel, settings page, large images).
      Code Splitting → Best for structuring large apps into manageable chunks.

12. What is the difference between React Router v5 and v6?
Ans = Differences Between React Router v5 and v6

      Route Matching
      v5 → Uses <Switch> to render the first matching route.
      v6 → Uses <Routes> which always matches exactly one route and is more predictable.

      Route Declaration
      v5 → <Route path="/home" component={Home} />
      v6 → <Route path="/home" element={<Home />} /> (uses element instead of component).

      Nested Routes
      v5 → More manual setup; often requires multiple <Route> definitions.
      v6 → Built‑in support for nested routes with cleaner syntax.

      Hooks
      v5 → Limited hooks (useHistory, useLocation).
      v6 → Modern hooks (useNavigate, useParams, useRoutes) that simplify navigation and route handling.

      Redirects
      v5 → Uses <Redirect> component.
      v6 → Redirects are handled with <Navigate> element.

      Bundle Size & Performance
      v5 → Larger and less optimized.
      v6 → Smaller, faster, and optimized for modern React.

      Default Behavior
      v5 → Routes are matched inclusively (multiple routes can match).
      v6 → Routes are matched exclusively (only one route matches).

      Upgrade Path
      v5 → Widely used but now legacy.
      v6 → Actively maintained, recommended for new projects, with a compatibility package for gradual upgrades
